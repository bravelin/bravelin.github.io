webpackJsonp([30],{gPKX:function(r,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n={extends:t("3ErM").a},v={render:function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("div",{staticClass:"page article"},[t("h2",{staticClass:"title"},[r._v("《ES6标准入门》笔记之十一：二进制数组")]),r._v(" "),r._m(0),r._v(" "),t("footer",[r._v("2017年05月18日")]),r._v(" "),t("Comments"),r._v(" "),t("Catalog",{attrs:{catalog:r.catalog}})],1)},staticRenderFns:[function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("div",{staticClass:"content"},[t("p",[r._v("二进制数组是JS操作二进制数据的接口。其目的是方便浏览器（WebGL）与显卡之间进行大量的、实时的交换数据。类似C语言的数组，可以直接操作内存。包括以下3类对象：")]),r._v(" "),t("p",[t("strong",[r._v("ArrayBuffer对象")]),r._v("：代表内存中的一段二进制数据，可以通过“视图”进行操作。")]),r._v(" "),t("p",[t("strong",[r._v("TypedArray对象")]),r._v("：共包括9种类型的视图，包括Int8、Uint8、Uint8C、Int16、Uint16、Int32、Uint32、Float32、Float64，主要用于读写简单类型的二进制数据。")]),r._v(" "),t("p",[t("strong",[r._v("DataView对象")]),r._v("：自定义复合格式的视图。")]),r._v(" "),t("h3",{staticClass:"title"},[r._v("ArrayBuffer对象")]),r._v(" "),t("p",[r._v("代表存储二进制数据的一段内存，"),t("strong",[r._v("不能直接读写，只能通过视图进行读写。")]),r._v("同时也是一个构造函数，用于分配一段可以存放数据的连续区域：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(bytes) // bytes代表字节数，每个字节默认值为0")])]),r._v(" "),t("p",[r._v("使用DataView读取ArrayBuffer：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar dataView = new DataView(buf)\ndataView.getUint8(0) // 无符号8位整数格式读取：0")])]),r._v(" "),t("p",[r._v("TypedArray视图是一组构造函数，代表不同的数据格式：")]),r._v(" "),t("pre",[t("code",[r._v("var buffer = new ArrayBuffer(12)\nvar x1 = new Int32Array(buffer) // 32位带符号整数\nx1[0] = 1\nvar x2 = new Uint8Array(buffer) // 8位无符号整数\nx2[0] = 2\nx1[0] // 2")])]),r._v(" "),t("p",[r._v("ArrayBuffer实例的byteLength属性，返回所分配的内存区域字节长度。如果要分配的内存区域很大，有可能分配失败，因此有必要检查是否分配成功：")]),r._v(" "),t("pre",[t("code",[r._v("if (buf.byteLength == n) {\n    // 分配成功\n} else {\n    // 分配失败\n}")])]),r._v(" "),t("p",[r._v("ArrayBuffer实例的slice()方法，可以将内存区域的一部分复制生成一个新的ArrayBuffer对象：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(8)\nvar newBuf = buf.slice(0, 3) // 复制前3个字节")])]),r._v(" "),t("p",[r._v("slice方法的第一个参数表示复制开始的字节序号（含该字节），第二个参数表示复制结束的字节序号（不含，默认到结尾）。")]),r._v(" "),t("p",[t("strong",[r._v("ArrayBuffer.isView()")]),r._v("，静态方法，判断参数是否为ArrayBuffer的视图实例：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar v = new Int32Array(buf)\nArrayBuffer.isView(v) // true")])]),r._v(" "),t("h3",{staticClass:"title"},[r._v("TypedArray视图")]),r._v(" "),t("p",[r._v("TypedArray视图一共包括9种类型，每一种视图都是一种构造函数：")]),r._v(" "),t("p",[t("strong",[r._v("1、Int8Array")]),r._v("：8位有符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("2、Uint8Array")]),r._v("：8位无符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("3、Uint8ClampedArray")]),r._v("：8位无符号整数，溢出处理不同；")]),r._v(" "),t("p",[t("strong",[r._v("4、Int16Array")]),r._v("：16位有符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("5、Uint16Array")]),r._v("：16位无符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("6、Int32Array")]),r._v("：32位有符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("7、Uint32Array")]),r._v("：32位无符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("8、Float32Array")]),r._v("：32位浮点数；")]),r._v(" "),t("p",[t("strong",[r._v("9、Float64Array")]),r._v("：64位浮点数；")]),r._v(" "),t("p",[r._v("普通数组与TypedArray数组的区别：")]),r._v(" "),t("p",[t("strong",[r._v("1、TypedArray数组的所有成员都是同一种类型；")])]),r._v(" "),t("p",[t("strong",[r._v("2、TypedArray数组的成员是连续的，不会有空位；")])]),r._v(" "),t("p",[t("strong",[r._v("3、TypedArray数组成员的默认值是0.")])]),r._v(" "),t("p",[t("strong",[r._v("4、TypedArray数组只是一层视图，本身不储存数据。")])]),r._v(" "),t("p",[r._v("构造函数原型："),t("strong",[r._v("TypedArray(buffer, byteOffset=0, length?)")]),r._v("：第一个参数必须，指向底层ArrayBuffer对象；第二个可选，视图开始的字节序号，默认为0；第三个可选，视图包含的数据个数，默认到内存区域结尾。")]),r._v(" "),t("p",[r._v("注意，byteOffset必须与所要建立的数据类型一致，否则会报错：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar v = new Int16Array(buf, 1) // ERROR")])]),r._v(" "),t("p",[r._v("如果需要从任意字节开始解读ArrayBuffer对象，必须使用DataView视图。")]),r._v(" "),t("p",[t("strong",[r._v("TypedArray(length)")]),r._v("：视图还可以不通过ArrayBuffer，直接分配内存生成。")]),r._v(" "),t("pre",[t("code",[r._v("var f64a = new Float64Array(8) // 64字节")])]),r._v(" "),t("p",[t("strong",[r._v("TypedArray(typedArray)")]),r._v("：接收另外一个TypedArray实例作为参数构造生成，此时新数组会开辟新的内存区域储存数据，不会在原数组的内存区域之上建立视图。")]),r._v(" "),t("pre",[t("code",[r._v("var x = new Int8Array([1, 1])\nvar y = new Int8Array(x)")])]),r._v(" "),t("p",[r._v("如果想基于相同的内存区域构造不同的视图，可以这样写：")]),r._v(" "),t("pre",[t("code",[r._v("var x = new Int8Array([1, 1])\nvar y = new Int8Array(x.buffer)")])]),r._v(" "),t("p",[t("strong",[r._v("TypedArray(arrayLikeObj)")]),r._v("：构造函数的参数也可以是一个普通数组，直接生成TypedArray实例。此时会重新开辟内存区域。")]),r._v(" "),t("p",[t("strong",[r._v("字节序")]),r._v("：指的是数值在内存中的表示方式：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(16)\nvar int32View = new Int32Array(buf)\nfor (var i = 0; i < int32View.length; i++) {\n    int32View[i] = i * 2\n}\nconsole.log(int32View) // 0 2 4 6\nvar int16View = new Int16Array(buf)\nconsole.log(int16View) // 0 0 2 0 4 0 6 0")])]),r._v(" "),t("p",[r._v("x86体系的计算机都采用"),t("strong",[r._v("小端字节序（litter endian），相对重要的字节（高字节）排在后面，不重要的字节（低字节）排在前面。大端字节序列则相反。TypedArray内部也采用小端字节序列读写。DataView对象可以设定字节序列。")])]),r._v(" "),t("p",[r._v("下面的方法可以判断当前视图是否是小端字节序，还是大端字节序：")]),r._v(" "),t("pre",[t("code",[r._v("const BIG_ENDIAN = Symbol('BIG_ENDINA')\nconst LITTER_ENDINA = Symbol('LITTER_ENDINA')\nfunction getPlatformEndianness() {\n    let arr32 = Uint32Array.of(0x12345678)\n    let arr8 = new Uint8Array(arr32.buffer)\n    switch ((arr8[0]*0x1000000) + (arr8[1]*0x10000) + (arr8[2]*0x100)+(arr8[3])) {\n        case 0x12345678: return BIG_ENDIAN;\n        case 0x78563412: return LITTER_ENDINA;\n        default: throw new Error('Unknow endianness')\n    }\n}")])]),r._v(" "),t("p",[r._v("每一种TypedArray视图，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数：")]),r._v(" "),t("pre",[t("code",[r._v("Int8Array.BYTES_PER_ELEMENT // 1\nFloat64Array.BYTES_PER_ELEMENT // 8")])]),r._v(" "),t("p",[r._v("ArrayBuffer与字符串的相互转换：（前提是字符串的编码方法是确定的，比如UTF-16）")]),r._v(" "),t("pre",[t("code",[r._v("// ArrayBuffer转为字符串\nfunction ab2str(buf) {\n    return String.fromCharCode.apply(null, new Uint16Array(buf))\n}\n// 字符串转为ArrayBuffer\nfunction str2ab(str) {\n    var buf = new ArrayBuffer(str.length * 2)\n    var bufView = new Uint16Array(buf)\n    for(var i = 0; i < str.length; i++) {\n        bufView[i] = str.charCodeAt(i)\n    }\n    return buf\n}")])]),r._v(" "),t("p",[t("strong",[r._v("正向溢出(overflow)")]),r._v("：输入值大于当前数据类型的最大值时，最后得到的值是当前数据类型的最小值加上余值，再减去1；"),t("strong",[r._v("负向溢出(underflow)")]),r._v("：输入值小于当前数据类型的最小值时，当前数据类型的最大值减去余值，再加上1。")]),r._v(" "),t("pre",[t("code",[r._v("var uint8 = new Uint8Array(1)\nuint8[0] = 256 // 0\nuint8[0] = -1 // 255\nvar int8 = new Int8Array(1)\nint8[0] = 128 // -128\nint8[0] = -129 // 127")])]),r._v(" "),t("p",[t("strong",[r._v("Uint8ClampedArray")]),r._v("视图的溢出与上面的规则不同，正向溢出都等于255，负向溢出都等于0：")]),r._v(" "),t("pre",[t("code",[r._v("var uint8c = new Uint8ClampedArray(1)\nuint8c[0] = 256 // 255\nuint8c[0] = -1 // 0")])]),r._v(" "),t("p",[t("strong",[r._v("TypedArray.prototype.buffer")]),r._v("：返回整段内存区域对应的ArrayBuffer对象。")]),r._v(" "),t("p",[t("strong",[r._v("TypedArray.prototype.byteLength")]),r._v("：返回数组占据的内存长度。")]),r._v(" "),t("p",[t("strong",[r._v("TypedArray.prototype.length")]),r._v("：返回数组的成员数目。")]),r._v(" "),t("p",[t("strong",[r._v("TypedArray.prototype.byteOffset")]),r._v("：返回数组从底层ArrayBuffer对象的哪个字节开始。")]),r._v(" "),t("p",[t("strong",[r._v("TypedArray.prototype.set()")]),r._v("：用于复制数组（普通数组或者TypedArray数组）,将一段内存完全复制到另外一段内存,可以指定从哪个位置开始复制。")]),r._v(" "),t("pre",[t("code",[r._v("var a = new Uint8Array(8)\nvar b = new Uint8Array(10)\nb.set(a, 2) // 从a[2]开始")])]),r._v(" "),t("p",[t("strong",[r._v("TypedArray.prototype.subarray()")]),r._v("：对于TypedArray的一部分再建立一个新的视图，第1个参数是起始的字节序号，第2个参数是结束成员序号（不包含）：")]),r._v(" "),t("pre",[t("code",[r._v("var a = new Uint8Array(8)\nvar b = a.subarray(2,3)\nb.byteLength // 1")])]),r._v(" "),t("p",[t("strong",[r._v("TypedArray.prototype.slice()")]),r._v("：返回一个指定位置的新的TypedArray实例，支持负值：")]),r._v(" "),t("pre",[t("code",[r._v("let uint8 = Uint8Array.of(1,2,3)\nuint8.slice(-1) // [3]")])]),r._v(" "),t("p",[t("strong",[r._v("TypedArray.of()")]),r._v("：静态方法，用于将参数转为一个TypedArray实例。")]),r._v(" "),t("pre",[t("code",[r._v("Float32Array.of(0.1,0.2,3)")])]),r._v(" "),t("p",[r._v("TypedArray的构造方法：")]),r._v(" "),t("pre",[t("code",[r._v("let a1 = new Uint8Array([1,2,3])\nlet a2 = new Uint8Array.of(1,2,3)\nlet a3 = new Uint8Array(3)\na3[0] = 1\na3[1] = 2\na3[2] = 3")])]),r._v(" "),t("p",[t("strong",[r._v("TypedArray.from()")]),r._v("：接受一个可遍历的结构（比如数组）作为参数，返回一个基于此结构的TypedArray实例。")]),r._v(" "),t("pre",[t("code",[r._v("Uint16Array.from([0,1,2])")])]),r._v(" "),t("p",[r._v("还可以将一种TypedArray转为另外一种：")]),r._v(" "),t("pre",[t("code",[r._v("var uint16 = Uint16Array.from(Uint8Array.of(1,2,3))")])]),r._v(" "),t("p",[r._v("还可以接受一个函数作为第二个参数，对每个元素进行遍历：")]),r._v(" "),t("pre",[t("code",[r._v("Int16Array.from(Int8Array.of(1,2,3), x => 2*x) // [2,4,6]")])]),r._v(" "),t("h3",{staticClass:"title"},[r._v("复合视图")]),r._v(" "),t("p",[r._v("视图的构造函数可以指定起始位置和长度，所以在同一段内存中可以依次存放不同类型的数据：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(24)\nvar idView = new Uint32Array(buf,0,1) // 字节0~3：1个32位无符号整数\nvar userNameView = new Uint8Array(buf,4,16) // 字节4~19：16个8位无符号整数\nvar amountView = new Float32Array(buf, 20, 1) // 字节20~23:1个32位浮点数")])]),r._v(" "),t("h3",{staticClass:"title"},[r._v("DataView视图")]),r._v(" "),t("p",[r._v("DataView支持设定字节序，接受一个ArrayBuffer对象作为参数生成视图。")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar dv = new DateView(buf, 2, 4) // 支持设定起始位置和长度")])]),r._v(" "),t("p",[r._v("DataView实例的"),t("strong",[r._v("buffer、byteLength、byteOffset")]),r._v("属性与TypedArray含义一致。")]),r._v(" "),t("p",[r._v("DataView实例提供以下8个方法读取内存："),t("strong",[r._v("getInt8、getUint8、getInt16、getUint16、getInt32、getUint32、getFloat32、getFloat64")]),r._v("，方法的参数是一个字节序号，表示读取的起始位置：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar dv = new DataView(buf)\nvar v1 = dv.getUint8(0) // 从第0个字节读取一个uint8\nvar v2 = dv.getUint16(1) // 从第1个字节读取一个uint16")])]),r._v(" "),t("p",[r._v("如果一次读取两个或者两个以上的字节，则必须明确数据的储存方式，是小端序列还是大端序列（默认），如果是小端序列，第2个参数需要设定为true：")]),r._v(" "),t("pre",[t("code",[r._v("var v3 = dv.getUint8(4, true)")])]),r._v(" "),t("p",[r._v("DataView提供以下8个方法写入内存："),t("strong",[r._v("setUint8、setInt8、setUint16、setInt16、setInt32、setUint32、setFloat32、setFloat64")]),r._v("，接受3个参数，第1个参数表示写入的位置，第2个参数是写入的数据，第3个参数表面数据的储存方式（大小端）：")]),r._v(" "),t("pre",[t("code",[r._v("dv.setUint32(0, 32, true)")])])])}]},a=t("Z0/y")(n,v,!1,null,null,null);e.default=a.exports}});