webpackJsonp([22],{NsWg:function(o,v,t){"use strict";Object.defineProperty(v,"__esModule",{value:!0});var n={extends:t("3ErM").a},_={render:function(){var o=this,v=o.$createElement,t=o._self._c||v;return t("div",{staticClass:"page article"},[t("h2",{staticClass:"title"},[o._v("你不知道的JavaScript（上卷）笔记")]),o._v(" "),o._m(0),o._v(" "),t("footer",[o._v("2018年05月20日")]),o._v(" "),t("Comments"),o._v(" "),t("Catalog",{attrs:{catalog:o.catalog}})],1)},staticRenderFns:[function(){var o=this,v=o.$createElement,t=o._self._c||v;return t("div",{staticClass:"content"},[t("h3",{staticClass:"title"},[o._v("作用域")]),o._v(" "),t("p",[t("strong",[o._v("作用域")]),o._v("是存储变量并如何找寻变量的规则。通常将JavaScript归为动态或解释型语言，但"),t("strong",[o._v("实际上它是一门编译语言")]),o._v("，只是它不是提前编译，编译结果也不能移植。大部分情况下编译发生在执行前的几微秒，看起来像解释执行一样。")]),o._v(" "),t("p",[o._v("如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。如果执行LHS查询是，"),t("strong",[o._v("非严格模式下")]),o._v("，如果在顶层也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量。")]),o._v(" "),t("p",[t("strong",[o._v("严格模式下则会禁止自动或者隐式地创建全局变量。")])]),o._v(" "),t("p",[o._v("作用域查找会在找到的第一个匹配的标识符时停止。")]),o._v(" "),t("p",[t("strong",[o._v("有两种方式可以在运行时修改词法作用域：eval和width。")])]),o._v(" "),t("p",[o._v("默认的非严格模式下，如果eval中所执行的代码包含有一个或多个声明，就会对eval所处的词法作用域进行修改。")]),o._v(" "),t("p",[t("strong",[o._v("在严格模式中，eval在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域：")])]),o._v(" "),t("pre",[t("code",[o._v('function foo (str) {\n    "use strict";\n    eval(str);\n    console.log(a); // ReferenceError\n}\nfoo("var a=2")')])]),o._v(" "),t("p",[o._v("JS中还有其他一些功能效果和eval()类似，setTimeout和setInterval的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的代码。但这种功能已过时且不应该再使用。")]),o._v(" "),t("p",[o._v("width通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。")]),o._v(" "),t("p",[o._v("width可以将一个没有或者有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。"),t("strong",[o._v("这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到width所处的函数作用域中。")])]),o._v(" "),t("p",[t("strong",[o._v("严格模式下，width被禁止使用。")])]),o._v(" "),t("p",[o._v("try-catch结构在catch分局中具有块作用域。")]),o._v(" "),t("p",[o._v("for循环头部的let不仅将i绑定到了for循环的块中，实际上它将重新绑定到了循环的每一个迭代中。")]),o._v(" "),t("p",[t("strong",[o._v("函数声明会被提升，而函数表达式则不会。")])]),o._v(" "),t("pre",[t("code",[o._v("foo(); // TYpeError\nbar(); // ReferenceError\nvar foo = function bar () { }")])]),o._v(" "),t("p",[t("strong",[o._v("函数声明和变量声明都会被提升，函数会首先被提升，然后才是变量。")])]),o._v(" "),t("pre",[t("code",[o._v("foo(); // 1\nvar foo;\nfunction foo() { console.log(1) }\nfoo = function() { console.log(2) }")])]),o._v(" "),t("p",[o._v("后面的函数声明可以覆盖前面的声明。")]),o._v(" "),t("p",[t("strong",[o._v("闭包是基于词法作用域书写代码时所产生的自然结果。")])]),o._v(" "),t("p",[o._v("函数执行完毕之后依然持有对该作用域的引用，使得作用域不被GC回收，这个引用称之为"),t("strong",[o._v("闭包")]),o._v("。")]),o._v(" "),t("h3",{staticClass:"title"},[o._v("this")]),o._v(" "),t("p",[o._v("对于this，通常有两种误解：指向自身和指向函数的作用域。"),t("strong",[o._v("this是在运行时进行绑定的,并不是在编写时绑定,它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系,只取决于函数的调用方式。")])]),o._v(" "),t("p",[o._v("在代码中插入debugger，浏览器会在那里暂停执行从而进入调试模式。")]),o._v(" "),t("p",[t("em",[o._v("this的绑定规则：")])]),o._v(" "),t("p",[t("strong",[o._v("1、默认绑定")]),o._v("：无法应用其他规则时的默认规则，非严格模式下，绑定到全局对象；严格模式下则无法使用默认绑定。")]),o._v(" "),t("pre",[t("code",[o._v("function foo() {\n    console.log(this.a) // 2\n}\nvar a = 2\nfoo()")])]),o._v(" "),t("p",[t("strong",[o._v("2、隐式绑定")]),o._v("：调用位置有上下文对象，或者说被某个对象拥有。")]),o._v(" "),t("p",[o._v("隐式丢失的问题：")]),o._v(" "),t("pre",[t("code",[o._v("function foo() { console.log(this.a) }\nvar obj = { a: 2, foo: foo }\nvar a = 'oop'\nsetTimeout(obj.foo, 100) // oop")])]),o._v(" "),t("p",[o._v("此种情况下应用的是默认绑定，this绑定到全局对象或者undefined上面。")]),o._v(" "),t("p",[t("strong",[o._v("3、显式绑定")]),o._v("：使用call和apply方法，在第一个参数中传入要绑定this的对象。")]),o._v(" "),t("pre",[t("code",[o._v("// 辅助绑定函数\nfunction bind (fn, obj) {\n    return function () {\n        fn.apply(obj, arguments)\n    }\n}")])]),o._v(" "),t("p",[t("strong",[o._v("等价于Function.prototype.bind。")])]),o._v(" "),t("p",[t("strong",[o._v("4、new绑定")])]),o._v(" "),t("pre",[t("code",[o._v("function foo(a) {\n    this.a = a;\n}\nvar bar = new foo(2);\nconsole.log( bar.a ); // 2")])]),o._v(" "),t("p",[o._v("使用new来调用函数,或者说发生构造函数调用时，会自动执行下面的操作：创建(或者说构造)一个全新的对象；这个新对象会被执行[[原型]]连接；这个新对象会绑定到函数调用的this；如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个新对象。")])])}]},e=t("Z0/y")(n,_,!1,null,null,null);v.default=e.exports}});