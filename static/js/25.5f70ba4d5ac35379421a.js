webpackJsonp([25],{RvyY:function(e,r,t){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var a={extends:t("3ErM").a},v={render:function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("div",{staticClass:"page article"},[t("h2",{staticClass:"title"},[e._v("《ES6标准入门》笔记之六：数组的扩展")]),e._v(" "),e._m(0),e._v(" "),t("footer",[e._v("2017年03月21日")]),e._v(" "),t("Comments"),e._v(" "),t("Catalog",{attrs:{catalog:e.catalog}})],1)},staticRenderFns:[function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("div",{staticClass:"content"},[t("h3",{staticClass:"title"},[e._v("Array.from()")]),e._v(" "),t("p",[e._v("用于将两类的对象转为真正的数组：类似数组的对象（array-like object）和可遍历的对象（iterable，包括Set和Map）。")]),e._v(" "),t("pre",[t("code",[e._v("let arrLike = { '0' : 'a', '1' : 'b', '2' : 'c', length : 3 }\n// es5的写法\nvar arr1 = [].slice.call(arrLike) // [\"a\", \"b\", \"c\"]\n\n// es6的写法\nvar arr2 = Array.from(arrLike) // [\"a\", \"b\", \"c\"]")])]),e._v(" "),t("p",[e._v("常见的类似数组的对象有DOM操作的NodeList对象、函数内部的arguments对象。Array.from都可以将它们转为真正的数组。")]),e._v(" "),t("pre",[t("code",[e._v('var ps = document.querySelector(\'p\')\nArray.from(ps).forEach(function (p) { console.dir(p) }) // 数组对象才有forEach方法\n\nArray.from(\'abcde\') // ["a", "b", "c", "d", "e"] 字符串转数组\n\nlet newSet = new Set([\'a\', \'b\'])\nArray.from(newSet) // ["a", "b"]')])]),e._v(" "),t("p",[e._v("因为字符串和Set都有Iterator结构，因此可以被Array.from转为正真的数组。")]),e._v(" "),t("p",[t("strong",[e._v("扩展运算符（...）也可以将某些数据结构转为数组：")])]),e._v(" "),t("pre",[t("code",[e._v("function foo() { var args = [...arguments] } // arguments对象\n[...document.querySelectorAll('div')] // NodeList对象")])]),e._v(" "),t("p",[e._v("扩展运算符背后调用的是遍历器接口（Symbol.iterator）；如果一个对象没有这个接口，将无法转换。")]),e._v(" "),t("p",[t("strong",[e._v("类似数组的对象本质特征是具有length属性。")]),e._v("任何有此属性的对象，都可以通过Array.from方法进行转换。")]),e._v(" "),t("pre",[t("code",[e._v("Array.from({ length: 3 }) // [undefined, undefined, undefined]")])]),e._v(" "),t("p",[e._v("Array.from可以接受第二个参数，作用类似数组的map方法，用来对每个元素进行处理，将处理之后的值返回放入的数组。")]),e._v(" "),t("pre",[t("code",[e._v("Array.from([1, 2, 3], (x) => x * x ) // [1, 4, 9]\nArray.from({ length: 2}, () => 'jack' ) // ['jack', 'jack']")])]),e._v(" "),t("h3",{staticClass:"title"},[e._v("Array.of()")]),e._v(" "),t("p",[e._v("用于将一组值转为数组，弥补数组构造函数Array()的不足。")]),e._v(" "),t("pre",[t("code",[e._v("Array.of(1, 2, 3) // [1, 2, 3]\nArray.of() // []\nArray.of(3) // [3]")])]),e._v(" "),t("p",[e._v("等价于下面的方法：")]),e._v(" "),t("pre",[t("code",[e._v("function ArrayOf() { return [].slice.call(arguments) }")])]),e._v(" "),t("h3",{staticClass:"title"},[e._v("数组实例的copyWithin()")]),e._v(" "),t("p",[e._v("在当前数组内将指定位置的成员复制到其他的位置（覆盖原有的成员），然后返回当前数组。")]),e._v(" "),t("p",[t("strong",[e._v("Array.prototype.copyWithin(target, start = 0, end = this.length)")]),e._v("：target是从该位置开始替换数据；start是从该位置读取数据，默认为0（可以用负值表示倒数）；end表示到该位置前停止读取数据，默认为数组的长度（可以用负值表示倒数）。")]),e._v(" "),t("pre",[t("code",[e._v("[1,2,3,4,5].copyWithin(0,2) // [3, 4, 5, 4, 5]\n[1,2,3,4,5].copyWithin(0,-2) // [4, 5, 3, 4, 5]")])]),e._v(" "),t("h3",{staticClass:"title"},[e._v("数组实例的find()和findIndex()")]),e._v(" "),t("p",[e._v("find()方法用于查找第一个符合条件的数组成员，它的参数是一个回调函数，所有数组成员依次执行此函数，直到找出第一个返回true的成员，然后返回该成员；如果没有符合条件的，返回undefined。")]),e._v(" "),t("pre",[t("code",[e._v("[1,2,3,4].find(function(value, index, arr) { return value > 3 }) // 4 找出大于3的成员")])]),e._v(" "),t("p",[e._v("回调函数可以接受3个参数，依次为当前值、当前的位置和原数组。")]),e._v(" "),t("p",[e._v("findIndex()和find()方法类似，不同的是它返回的是符合条件的成员的位置，如果所有成员都不符合，则返回-1。")]),e._v(" "),t("h3",{staticClass:"title"},[e._v("数组实例的fill()")]),e._v(" "),t("p",[e._v("使用给定值填充数组，返回填充之后的数组。")]),e._v(" "),t("p",[t("strong",[e._v("Array.prototype.fill(value, start = 0, end = this.length)")]),e._v("：value是填充的值，start是起始填充位置，end表示到该位置之前结束填充。")]),e._v(" "),t("pre",[t("code",[e._v("[1,2,3].fill(8) // [8, 8, 8]\n new Array(3).fill(6) // [6, 6, 6]")])]),e._v(" "),t("h3",{staticClass:"title"},[e._v("数组实例的entries()、keys()、values()")]),e._v(" "),t("p",[e._v("遍历数组的方法。都返回一个遍历器对象，可以用for...of循环遍历，唯一的区别是：keys()是对键名的遍历；values()是对键值得遍历；entries()是对键值对的遍历。")]),e._v(" "),t("pre",[t("code",[e._v("for(let index of ['a', 'b'].keys()) { console.log(index) }\n// 0\n// 1\n\nfor(let val of ['a', 'b'].values()) { console.log(val) } // chrome不支持\n// 'a'\n// 'b'\n\nfor(let [index, val] of ['a', 'b'].entries()) { console.log(index, val) }\n//0 'a'\n//1 'b'\n            ")])]),e._v(" "),t("h3",{staticClass:"title"},[e._v("数组实例的includes()")]),e._v(" "),t("p",[e._v("返回一个布尔值，表示数组是否包含给定的值。是属于ES7的内容。")]),e._v(" "),t("pre",[t("code",[e._v("[1, 2, 3].includes(3) // true")])]),e._v(" "),t("p",[e._v("该方法可以传入第二个参数，表示搜索的起始位置。indexOf方法也可以检查数组是否包含某个值：")]),e._v(" "),t("pre",[t("code",[e._v("if (arr.indexOf(el) !== -1) { }")])]),e._v(" "),t("p",[e._v("Map结构的has方法是用来查找键名的；Set结构的has方法是用来查找值得。")]),e._v(" "),t("h3",{staticClass:"title"},[e._v("数组的空位")]),e._v(" "),t("p",[e._v("数组的空位表示在该位置上没有任何值（不是undefined，也不是null）：")]),e._v(" "),t("pre",[t("code",[e._v("Array(3) // [, , ,]")])]),e._v(" "),t("p",[e._v("数组实例的方法对空位的处理不统一，需要避免出现空位。")]),e._v(" "),t("h3",{staticClass:"title"},[e._v("数组的推导")]),e._v(" "),t("p",[e._v("数组推导（array comprehension）属于ES7的内容，允许直接通过现有的数组生成新数组。")]),e._v(" "),t("pre",[t("code",[e._v("var a1 = [1, 2, 3, 4]\nvar a2 = [for(i of a1) i*2] // [2, 4, 6, 8]")])])])}]},n=t("rAbc")(a,v,!1,null,null,null);r.default=n.exports}});