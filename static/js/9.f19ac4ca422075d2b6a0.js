webpackJsonp([9],{LAAJ:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var a={extends:n("wkh7").a},i={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"page article"},[n("h2",{staticClass:"title"},[t._v("MpVue中使用WeCropper实现小程序中的图片裁剪")]),t._v(" "),t._m(0),t._v(" "),n("footer",[t._v("2018年05月12日")]),t._v(" "),n("comments"),t._v(" "),n("Catalog",{attrs:{catalog:t.catalog}})],1)},staticRenderFns:[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[n("h3",{staticClass:"title"},[t._v("在mpvue框架中使用")]),t._v(" "),n("p",[t._v("we-cropper——一款灵活小巧的canvas图片裁剪器，github地址："),n("a",{attrs:{target:"_blank",href:"https://github.com/we-plugin/we-cropper"}},[t._v("https://github.com/we-plugin/we-cropper")]),t._v("。")]),t._v(" "),n("p",[t._v("mpvue中可以通过npm install的方式引入到项目中，它封装了一个mpvue-cropper.vue组件可供使用。然而因为它提供的getCropperBase64方法在IOS中会导致图片翻转的严重问题。因此直接引入其源码文件we-cropper.js并修改。")]),t._v(" "),n("p",[t._v("裁剪页面template结构：")]),t._v(" "),n("pre",[n("code",[t._v('<template>\n    <div class="container cropper-wrapper" :style="{ height: height + \'px\' }">\n        <canvas class="cropper" disable-scroll="true" canvas-id="cropper" @touchstart="touchStart" @touchmove="touchMove" @touchend="touchEnd" :style="{width: cropperOption.width + \'px\', height: cropperOption.height + \'px\', \'background-color\': \'rgba(0, 0, 0, 0.8)\'}"></canvas>\n        <div class="cropper-buttons" style="height: 50px">\n            <div @click="doCancel" class="cancel-btn">取消</div>\n            <div @click="doCommit" class="commit-btn">确定</div>\n        </div>\n    </div>\n</template>')])]),t._v(" "),n("p",[t._v("touchStart、touchMove、touchEnd这3个事件的绑定发现是必须要的。")]),t._v(" "),n("p",[t._v("基本用法：")]),t._v(" "),n("pre",[n("code",[t._v("import WeCropper from '@/libs/we-cropper'\nconst device = wx.getSystemInfoSync() // 获取设备信息\nconst deviceWidth = device.windowWidth // 示例为一个与屏幕等宽的正方形裁剪框\nconst deviceHeight = device.windowHeight - 50\n\nexport default {\n    data () {\n        return {\n            height: deviceHeight,\n            wecropper: null, // 裁剪实例\n            cropperOption: {\n                id: 'cropper',\n                width: deviceWidth,  // 画布宽度\n                height: deviceHeight, // 画布高度\n                scale: 2.5, // 最大缩放倍数\n                zoom: 8, // 缩放系数\n                cut: {\n                    x: (deviceWidth - 300) / 2, // 裁剪框x轴起点\n                    y: (deviceHeight - 300) / 2, // 裁剪框y轴期起点\n                    width: 300, // 裁剪框宽度\n                    height: 300 // 裁剪框高度\n                }\n            }\n        }\n    },\n    onLoad (option) {\n        const that = this\n        let ratio = 1\n        let w = 300\n        let h = ratio * 300\n        let cutOpt = { // 此处可以调整裁剪框\n            x: (deviceWidth - w) / 2,\n            y: (deviceHeight - h) / 2,\n            width: w,\n            height: h\n        }\n        that.cropperOption.cut = cutOpt\n        if (option.src) { // 传入要裁剪图片的地址\n            that.cropperOption.src = option.src\n            that.wecropper = new WeCropper(that.cropperOption).on('beforeImageLoad', (ctx) => {\n                wx.showToast({ title: '上传中', icon: 'loading' })\n            }).on('imageLoad', (ctx) => {\n                wx.hideToast()\n            }).updateCanvas()\n        }\n    },\n    methods: {\n        touchStart (e) {\n            this.wecropper.touchStart(e.mp)\n        },\n        touchMove (e) {\n            this.wecropper.touchMove(e.mp)\n        },\n        touchEnd (e) {\n            this.wecropper.touchEnd(e.mp)\n        },\n        doCancel () { // 返回\n            wx.navigateBack()\n        },\n        doCommit () { // 提交\n            const that = this\n            that.wecropper.getCropperBase64(data => {\n                ...... // that.doUpload(), 获取到图片的base64编码，做上传处理\n            })\n        }\n    }\n}")])]),t._v(" "),n("p",[t._v("小程序的页面效果：")]),t._v(" "),n("figure",{staticClass:"common"},[n("img",{staticStyle:{"max-width":"420px"},attrs:{src:"http://800cx2.com1.z0.glb.clouddn.com/apicloud/dfcab4f8b2bc77f95e6a2b27ce0f38c9.png"}})]),t._v(" "),n("h3",{staticClass:"title"},[t._v("修复在IOS中翻转问题")]),t._v(" "),n("p",[t._v("在苹果手机中获取base64编码之后保存的图片是翻转的：")]),t._v(" "),n("figure",{staticClass:"common"},[n("img",{staticStyle:{"max-width":"420px"},attrs:{src:"http://800cx2.com1.z0.glb.clouddn.com/apicloud/66fc0ca5556509efc0d8fe9ad2d18d81.jpg"}})]),t._v(" "),n("p",[t._v("一开始认为we-cropper.js在加载图片之后没有处理orientation导致。小程序的接口getImageInfo()在1.9.90版本增加了表示图片方向的orientation字段：")]),t._v(" "),n("figure",{staticClass:"common"},[n("img",{attrs:{src:"http://800cx2.com1.z0.glb.clouddn.com/apicloud/337c2037167b8d72a0c593a6917b28f9.png"}})]),t._v(" "),n("p",[t._v("但调试中发现加载图片时返回的orientation依然是up，并不是down、left、right之类的值...")]),t._v(" "),n("p",[t._v("之后打算在生成base64编码之前将图片旋转180度：")]),t._v(" "),n("pre",[n("code",[t._v("self.updateCanvas = function (putResCanvas) {\n    if (self.croperTarget) {\n        // 画布绘制图片\n        let ctx = self.ctx\n        if (putResCanvas && isIOS) { // 旋转180度\n            ctx.save()\n            ctx.translate(boundWidth/2, boundHeight/2)\n            ctx.rotate(Math.PI)\n            ctx.drawImage(self.croperTarget, self.imgLeft - boundWidth/2, self.imgTop - boundHeight/2, self.scaleWidth, self.scaleHeight);\n            ctx.restore()\n        } else { // 正常的绘制\n            ctx.drawImage(self.croperTarget, self.imgLeft, self.imgTop, self.scaleWidth, self.scaleHeight);\n        }\n    }\n    isFunction(self.onBeforeDraw) && self.onBeforeDraw(self.ctx, self);\n    ...... // 后续代码\n}\n")])]),t._v(" "),n("p",[t._v("获取base64编码之前重绘，再次调用updateCanvas，在IOS中可以看到此时图片突然倒置了（不过这个时候已经在保存提交中了）：")]),t._v(" "),n("pre",[n("code",[t._v("self.getCropperBase64 = function (done) {\n    if ( done === void 0 ) done = function () {};\n    self.updateCanvas(true) // putResCanvas标志传入true\n\n    CanvasToBase64.convertToBMP... // 后续代码\n}")])]),t._v(" "),n("p",[t._v("真实效果中，翻转与旋转180度的效果并不是一样的：")]),t._v(" "),n("p",[t._v("裁剪的图片：")]),t._v(" "),n("figure",{staticClass:"common"},[n("img",{staticStyle:{"max-width":"420px"},attrs:{src:"http://800cx2.com1.z0.glb.clouddn.com/apicloud/31484b1ec2bc92715b641cb050f92d0b.png"}})]),t._v(" "),n("p",[t._v("使用旋转180度方式生成的图片：")]),t._v(" "),n("figure",{staticClass:"common"},[n("img",{staticStyle:{"max-width":"420px"},attrs:{src:"http://800cx2.com1.z0.glb.clouddn.com/apicloud/a86828651ef5a4b054bf34f1874995e1.png"}})]),t._v(" "),n("p",[t._v("可以看到图片左右方向反了，所以上述方法是行不通的。")]),t._v(" "),n("p",[t._v("比较可行的方式是修改获取base64编码时构建位图数据的方式，可以看到we-cropper.js中是以倒序的方式读取每一行的像素数据：")]),t._v(" "),n("pre",[n("code",[t._v("function genBitmapImage (oData) {\n    ......\n    var y = biHeight;\n    var fromCharCode = String.fromCharCode;\n\n    do { // 逆序读取\n        var iOffsetY = biWidth4 * (y - 1);\n        var strPixelRow = '';\n        for (var x = 0; x < biWidth; x++) {\n        var iOffsetX = x << 2;\n        strPixelRow += fromCharCode(aImgData[iOffsetY + iOffsetX + 2]) +\n            fromCharCode(aImgData[iOffsetY + iOffsetX + 1]) +\n            fromCharCode(aImgData[iOffsetY + iOffsetX]);\n        }\n\n        for (var c = 0; c < iPadding; c++) {\n            strPixelRow += String.fromCharCode(0);\n        }\n\n        strPixelData += strPixelRow;\n    } while (--y)\n    ......\n}")])]),t._v(" "),n("p",[t._v("如果这种逆序的读取方式会使IOS的图片翻转的话，那么正序读取岂不是就正常了？修改如下：")]),t._v(" "),n("p",[t._v("在最顶部增加定义isIOS和fromCharCode：")]),t._v(" "),n("pre",[n("code",[t._v("var isIOS = false; // 判定设备是否是苹果手机\nvar fromCharCode = String.fromCharCode;")])]),t._v(" "),n("p",[t._v("attachPage方法中调用wx.getSystemInfo，判定设备是否是苹果手机：")]),t._v(" "),n("pre",[n("code",[t._v("self.attachPage = function () {\n    ......\n    wx.getSystemInfo({\n        success (res) {\n            isIOS = /ios/i.test(res.system)\n        }\n    })\n}")])]),t._v(" "),n("p",[t._v("修改genBitmapImage方法：")]),t._v(" "),n("pre",[n("code",[t._v("function genBitmapImage (oData) {\n    ......\n    var iPadding = (4 - ((biWidth * 3) % 4)) % 4;\n    var aImgData = oData.data;\n    var strPixelData = '';\n    var biWidth4 = biWidth << 2;\n    var y = biHeight;\n\n    if (isIOS) { // 倒置情况下\n        for (y = 0; y < biHeight; y++) {\n            strPixelData += getRowPixelData(y, biWidth4, biWidth, aImgData, iPadding)\n        }\n    } else { // 正常情况下\n        for (y = biHeight - 1; y >= 0; y--) {\n            strPixelData += getRowPixelData(y, biWidth4, biWidth, aImgData, iPadding)\n        }\n    }\n\n    var strEncoded = encodeData(BITMAPFILEHEADER.concat(BITMAPINFOHEADER)) + encodeData(strPixelData);\n    return strEncoded\n}")])]),t._v(" "),n("p",[t._v("增加getRowPixelData方法：")]),t._v(" "),n("pre",[n("code",[t._v("function getRowPixelData (y, biWidth4, biWidth, aImgData, iPadding) {\n    var iOffsetY = biWidth4 * y;\n    var strPixelRow = '';\n    var iOffsetX\n    for (var x = 0; x < biWidth; x++) {\n        iOffsetX = x << 2;\n        strPixelRow += fromCharCode(aImgData[iOffsetY + iOffsetX + 2]) + fromCharCode(aImgData[iOffsetY + iOffsetX + 1]) + fromCharCode(aImgData[iOffsetY + iOffsetX]);\n    }\n    for (var c = 0; c < iPadding; c++) {\n        strPixelRow += fromCharCode(0);\n    }\n    return strPixelRow\n}")])]),t._v(" "),n("p",[t._v("如此修改即可修复图片翻转问题。")])])}]},o=n("rAbc")(a,i,!1,null,null,null);e.default=o.exports}});