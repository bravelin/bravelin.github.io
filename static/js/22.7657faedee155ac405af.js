webpackJsonp([22],{NsWg:function(t,v,e){"use strict";Object.defineProperty(v,"__esModule",{value:!0});var _={extends:e("3ErM").a},o={render:function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("div",{staticClass:"page article"},[e("h2",{staticClass:"title"},[t._v("你不知道的JavaScript（上卷）笔记")]),t._v(" "),t._m(0),t._v(" "),e("footer",[t._v("2018年05月20日")]),t._v(" "),e("Comments"),t._v(" "),e("Catalog",{attrs:{catalog:t.catalog}})],1)},staticRenderFns:[function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("div",{staticClass:"content"},[e("h3",{staticClass:"title"},[t._v("作用域")]),t._v(" "),e("p",[e("strong",[t._v("作用域")]),t._v("是存储变量并如何找寻变量的规则。通常将JavaScript归为动态或解释型语言，但"),e("strong",[t._v("实际上它是一门编译语言")]),t._v("，只是它不是提前编译，编译结果也不能移植。大部分情况下编译发生在执行前的几微秒，看起来像解释执行一样。")]),t._v(" "),e("p",[t._v("如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。如果执行LHS查询是，"),e("strong",[t._v("非严格模式下")]),t._v("，如果在顶层也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量。")]),t._v(" "),e("p",[e("strong",[t._v("严格模式下则会禁止自动或者隐式地创建全局变量。")])]),t._v(" "),e("p",[t._v("作用域查找会在找到的第一个匹配的标识符时停止。")]),t._v(" "),e("p",[e("strong",[t._v("有两种方式可以在运行时修改词法作用域：eval和width。")])]),t._v(" "),e("p",[t._v("默认的非严格模式下，如果eval中所执行的代码包含有一个或多个声明，就会对eval所处的词法作用域进行修改。")]),t._v(" "),e("p",[e("strong",[t._v("在严格模式中，eval在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域：")])]),t._v(" "),e("pre",[e("code",[t._v('function foo (str) {\n    "use strict";\n    eval(str);\n    console.log(a); // ReferenceError\n}\nfoo("var a=2")')])]),t._v(" "),e("p",[t._v("JS中还有其他一些功能效果和eval()类似，setTimeout和setInterval的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的代码。但这种功能已过时且不应该再使用。")]),t._v(" "),e("p",[t._v("width通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。")]),t._v(" "),e("p",[t._v("width可以将一个没有或者有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。"),e("strong",[t._v("这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到width所处的函数作用域中。")])]),t._v(" "),e("p",[e("strong",[t._v("严格模式下，width被禁止使用。")])]),t._v(" "),e("p",[t._v("try-catch结构在catch分局中具有块作用域。")]),t._v(" "),e("p",[t._v("for循环头部的let不仅将i绑定到了for循环的块中，实际上它将重新绑定到了循环的每一个迭代中。")]),t._v(" "),e("p",[e("strong",[t._v("函数声明会被提升，而函数表达式则不会。")])]),t._v(" "),e("pre",[e("code",[t._v("foo(); // TYpeError\nbar(); // ReferenceError\nvar foo = function bar () { }")])]),t._v(" "),e("p",[e("strong",[t._v("函数声明和变量声明都会被提升，函数会首先被提升，然后才是变量。")])]),t._v(" "),e("pre",[e("code",[t._v("foo(); // 1\nvar foo;\nfunction foo() { console.log(1) }\nfoo = function() { console.log(2) }")])]),t._v(" "),e("p",[t._v("后面的函数声明可以覆盖前面的声明。")]),t._v(" "),e("p",[e("strong",[t._v("闭包是基于词法作用域书写代码时所产生的自然结果。")])]),t._v(" "),e("p",[t._v("函数执行完毕之后依然持有对该作用域的引用，使得作用域不被GC回收，这个引用称之为"),e("strong",[t._v("闭包")]),t._v("。")]),t._v(" "),e("h3",{staticClass:"title"},[t._v("this和对象原型")])])}]},r=e("Z0/y")(_,o,!1,null,null,null);v.default=r.exports}});