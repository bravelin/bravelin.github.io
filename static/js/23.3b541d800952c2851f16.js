webpackJsonp([23],{q1Hs:function(t,_,v){"use strict";Object.defineProperty(_,"__esModule",{value:!0});var e={extends:v("wkh7").a},n={render:function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("div",{staticClass:"page article"},[v("h2",{staticClass:"title"},[t._v("《ES6标准入门》笔记之五：数值的扩展")]),t._v(" "),t._m(0),t._v(" "),v("footer",[t._v("2017年03月17日")]),t._v(" "),v("comments"),t._v(" "),v("Catalog",{attrs:{catalog:t.catalog}})],1)},staticRenderFns:[function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("div",{staticClass:"content"},[v("h3",{staticClass:"title"},[t._v("二进制和八进制数值表示法")]),t._v(" "),v("p",[t._v("ES6对二进制和八进制提供了新的表示方法：分别用前缀0b(0B)和0o(0O)表示：")]),t._v(" "),v("pre",[v("code",[t._v("0b111110111 === 503\n0o767 === 503")])]),t._v(" "),v("p",[t._v("在严格模式中，八进制数据不允许使用0前缀表示，需使用0o前缀。使用Number方法可以将这种前缀表示的数值字符串转为十进制数值：")]),t._v(" "),v("pre",[v("code",[t._v("Number('0b111110111') // 503\nNumber('0o767') // 503")])]),t._v(" "),v("h3",{staticClass:"title"},[t._v("Number.isFinite()、Number.isNaN()")]),t._v(" "),v("p",[t._v("分别用来检查Infinite和NaN这两个特殊值。")]),t._v(" "),v("p",[t._v("Number.isFinite()用来检查一个数值是否"),v("strong",[t._v("非无穷")]),t._v("（infinity）。")]),t._v(" "),v("p",[t._v("Number.isNaN()用来检查一个值是否为NaN。")]),t._v(" "),v("p",[t._v("这两个方法与传统的全局方法isFinite()和isNaN()的区别在于，"),v("strong",[t._v("传统的方法会先调用Number将非数值转为数值，再进行判断。而新方法只对数值有效。")])]),t._v(" "),v("pre",[v("code",[t._v("isFinite(25) // true\nisFinite('25') // true\nNumber.isFinite(25) // true\nNumber.isFinite('25') // false\nisNaN('NaN') // true\nNumber.isNaN('NaN') // false")])]),t._v(" "),v("h3",{staticClass:"title"},[t._v("Number.parseInt()、Number.parseFloat()")]),t._v(" "),v("p",[t._v("与传统的全局方法parseInt()和parseFloat()是等价的，只是移植到了Number对象上。")]),t._v(" "),v("p",[t._v("其目的是逐步减少全局方法，使语言逐步模块化。")]),t._v(" "),v("h3",{staticClass:"title"},[t._v("Number.isInteger()")]),t._v(" "),v("p",[t._v("用来判断一个值是否为整数。在JS内部，整数和浮点数是相同的存储方法，3和3.0是相同的数值。")]),t._v(" "),v("pre",[v("code",[t._v("Number.isInteger(3) // true\nNumber.isInteger(3.0) // true\nNumber.isInteger('3') // false")])]),t._v(" "),v("h3",{staticClass:"title"},[t._v("Number.EPSILON")]),t._v(" "),v("p",[t._v("新增的极小常量：")]),t._v(" "),v("pre",[v("code",[t._v('Number.EPSILON // 2.220446049250313e-16\nNumber.EPSILON.toFixed(20) // "0.00000000000000022204"')])]),t._v(" "),v("p",[t._v("因为浮点数的计算是不精确的，可以利用这个值设置误差范围：")]),t._v(" "),v("pre",[v("code",[t._v("function withinErrorMargin (v1, v2) { // 判断两个值是否相等（在一定误差范围之内）\n        return Math.abs(v1 - v2) < Number.EPSILON\n}\nwithinErrorMargin(0.1 + 0.2, 0.3) // true\n0.1+0.2 == 0.3 // false")])]),t._v(" "),v("h3",{staticClass:"title"},[t._v("Number.isSafeInteger()")]),t._v(" "),v("p",[t._v("JS可以精确表示的整数范围是-2"),v("sup",[t._v("53")]),t._v("~2"),v("sup",[t._v("53")]),t._v("之间，超出这个范围无法精确表示。ES6新增了"),v("strong",[t._v("Number.MAX_SAFE_INTEGER")]),t._v("和"),v("strong",[t._v("Number.MIN_SAFE_INTEGER")]),t._v("两个常量，用来表示这个范围的上下限。")]),t._v(" "),v("p",[t._v("Number.isSafeInteger()用来判断一个"),v("strong",[t._v("整数")]),t._v("是否位于这个范围之内。")]),t._v(" "),v("pre",[v("code",[t._v("Math.pow(2,53) // 9007199254740992\nMath.pow(2,53)+1 // 9007199254740992\nMath.pow(-2,53) // -9007199254740992\nMath.pow(-2,53)-1 // -9007199254740992\n\nNumber.MAX_SAFE_INTEGER // 9007199254740991\nNumber.MIN_SAFE_INTEGER // -9007199254740991")])]),t._v(" "),v("pre",[v("code",[t._v("Number.isSafeInteger('a') // false\nNumber.isSafeInteger(null) // false\nNumber.isSafeInteger(NaN) // false\nNumber.isSafeInteger(1.2) // false\nNumber.isSafeInteger(1.0) // true")])]),t._v(" "),v("h3",{staticClass:"title"},[t._v("Math对象的扩展")]),t._v(" "),v("p",[t._v("Math对象新增了17个与数学相关的静态方法。")]),t._v(" "),v("p",[v("strong",[t._v("1、Math.trunc()")])]),t._v(" "),v("p",[t._v("用于获取一个数（如果不是数值，会先转换）的整数部分：")]),t._v(" "),v("pre",[v("code",[t._v('Math.trunc(1.1) // 1\nMath.trunc(-1.1) // -1\nMath.trunc("-1.1") // -1')])]),t._v(" "),v("p",[t._v("等价于此方法：")]),t._v(" "),v("pre",[v("code",[t._v("function (x) {\n    return x > 0 ? Math.floor(x) : Math.ceil(x)\n}")])]),t._v(" "),v("p",[v("strong",[t._v("2、Math.sign()")])]),t._v(" "),v("p",[t._v("用于判断一个数是正数、负数、0：参数为正数，返回1；参数为负数，返回-1；参数为0，返回0，参数为-0，返回-0；其他值，返回NaN。")]),t._v(" "),v("pre",[v("code",[t._v("Math.sign(11) // 1\nMath.sign(-11) // -1\nMath.sign(-0) // -0\nMath.sign(0) // 0\nMath.sign('A') // NaN")])]),t._v(" "),v("p",[v("strong",[t._v("3、Math.cbrt()")])]),t._v(" "),v("p",[t._v("用于计算一个数（如果不是数值，会先转换）的立方根：")]),t._v(" "),v("pre",[v("code",[t._v("Math.cbrt(2) // 1.2599210498948732")])]),t._v(" "),v("p",[t._v("等价于此方法：")]),t._v(" "),v("pre",[v("code",[t._v("function (x) {\n    var y = Math.pow(Math.abs(x), 1/3)\n    return x > 0 ? y : -y\n}")])]),t._v(" "),v("p",[v("strong",[t._v("4、Math.clz32()")])]),t._v(" "),v("p",[t._v('返回一个数的32位无符号整数形式有多少个前导0，函数名称来自"count leading zero bits in 32-bit binary representations of a number"')]),t._v(" "),v("pre",[v("code",[t._v("Math.clz32(1) // 31\nMath.clz32(0) // 32\nMath.clz32(1 << 1) // 30")])]),t._v(" "),v("p",[t._v("对于小数，该方法只考虑整数部分。其他非数值参数会先转换成数值。")]),t._v(" "),v("p",[v("strong",[t._v("5、Math.imul()")])]),t._v(" "),v("p",[t._v("返回两个数以32位带符号整数形式相乘的结果（也是一个32位带符号整数）。")]),t._v(" "),v("p",[t._v("如果只考虑32位，大多数情况下，Math.imul(a * b)与a * b的结果是相同的（（a * b）|0）。超出32位的部分溢出。")]),t._v(" "),v("pre",[v("code",[t._v("Math.imul(2, 4) // 8\nMath.imul(-2, -2) // 4\nMath.imul(0x7fffffff, 0x7fffffff) // 1")])]),t._v(" "),v("p",[t._v("之所以增加此方法，是因为JS有精度限制，超出2的53次方无法精确表示出来。Math.imul()可以返回正确的低位数值。")]),t._v(" "),v("p",[v("strong",[t._v("6、Math.fround()")])]),t._v(" "),v("p",[t._v("返回一个数的单精度浮点数形式：")]),t._v(" "),v("pre",[v("code",[t._v("Math.fround(1) // 1\nMath.fround(1.337) // 1.3370000123977661\nMath.fround(1.5) // 1.5")])]),t._v(" "),v("p",[t._v("对于整数，此方法返回同样的整数；区别在于那些无法使用64位二进制位表示精确表示的数，Math.fround()会返回最接近这个小数的单精度浮点数。")]),t._v(" "),v("p",[v("strong",[t._v("7、Math.hypot()")])]),t._v(" "),v("p",[t._v("此方法返回所有参数（如果参数不是数值，会先转换）平方和的平方根：")]),t._v(" "),v("pre",[v("code",[t._v("Math.hypot(3, 4) // 5\nMath.hypot(3, 4, 5) // 7.0710678118654755\nMath.hypot(-3) // 3")])]),t._v(" "),v("p",[v("strong",[t._v("8、Math.expm1()")])]),t._v(" "),v("p",[t._v("等价于Math.exp(x) - 1，即e的x次方再减去1的结果。")]),t._v(" "),v("pre",[v("code",[t._v("Math.expm1(1) // 1.718281828459045")])]),t._v(" "),v("p",[v("strong",[t._v("9、Math.log1p()")])]),t._v(" "),v("p",[t._v("等价于Math.log(1+x)，即求x加1之和的自然对数。")]),t._v(" "),v("pre",[v("code",[t._v("Math.log1p(Math.E-1) // 1")])]),t._v(" "),v("p",[v("strong",[t._v("10、Math.log10()")])]),t._v(" "),v("p",[t._v("返回以10为底的x的对数。")]),t._v(" "),v("pre",[v("code",[t._v("Math.log10(1000) // 3")])]),t._v(" "),v("p",[v("strong",[t._v("11、Math.log2()")])]),t._v(" "),v("p",[t._v("返回以2为底的x的对数。")]),t._v(" "),v("pre",[v("code",[t._v("Math.log2(1024) // 10")])]),t._v(" "),v("p",[v("strong",[t._v("12、Math.sinh(x)")]),t._v("：返回x的双曲正旋。")]),t._v(" "),v("p",[v("strong",[t._v("13、Math.cosh(x)")]),t._v("：返回x的双曲余旋。")]),t._v(" "),v("p",[v("strong",[t._v("14、Math.tanh(x)")]),t._v("：返回x的双曲正切。")]),t._v(" "),v("p",[v("strong",[t._v("15、Math.asinh(x)")]),t._v("：返回x的反双曲正旋。")]),t._v(" "),v("p",[v("strong",[t._v("16、Math.acosh(x)")]),t._v("：返回x的反双曲余旋。")]),t._v(" "),v("p",[v("strong",[t._v("17、Math.atanh(x)")]),t._v("：返回x的反双曲正切。")]),t._v(" "),v("h3",{staticClass:"title"},[t._v("指数运算符")]),t._v(" "),v("p",[t._v("ES7里面新增的一个运算符（**）")]),t._v(" "),v("pre",[v("code",[t._v("2 ** 4 // 16")])]),t._v(" "),v("p",[t._v("与等号结合，形成一个新的赋值运算符：（**=）")]),t._v(" "),v("pre",[v("code",[t._v("let b = 3\nb **= 3 // 27")])])])}]},r=v("Z0/y")(e,n,!1,null,null,null);_.default=r.exports}});