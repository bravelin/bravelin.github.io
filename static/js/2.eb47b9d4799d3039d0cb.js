webpackJsonp([2,42],{1:function(t,e){"use strict";t.exports={mounted:function(){this.$nextTick(function(){var t=document.querySelectorAll("code");if(t.length>0)for(var e=0;e<t.length;e++)hljs.highlightBlock(t[e])})}}},2:function(t,e,n){var a,r;a=n(1);var i=n(3);r=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(r=a=a.default),"function"==typeof r&&(r=r.options),r.render=i.render,r.staticRenderFns=i.staticRenderFns,t.exports=a},3:function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div")},staticRenderFns:[]}},21:function(t,e,n){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}var r=n(2),i=a(r);t.exports={extends:i.default,mounted:function(){var t=this;t.$nextTick(function(){t.initLinearGradient(),t.initRadialGradient(),t.drawTwoCircle(),t.initGrid(),t.drawDashedLine(),t.drawRoundedRect(),t.drawArrow(),t.drawClipAni()})},methods:{initLinearGradient:function(){var t=this,e=t.$refs,n=250,a=250;t.drawLinearGradient(e.c1,{x0:0,y0:0,x1:n,y1:0}),t.drawLinearGradient(e.c2,{x0:0,y0:0,x1:0,y1:a}),t.drawLinearGradient(e.c3,{x0:0,y0:0,x1:n,y1:a}),t.drawLinearGradient(e.c4,{x0:0,y0:0,x1:0,y1:a/2})},drawLinearGradient:function(t,e){var n=t.getContext("2d"),a=n.createLinearGradient(e.x0,e.y0,e.x1,e.y1);a.addColorStop(0,"#333"),a.addColorStop(1,"#fff"),n.fillStyle=a,n.fillRect(0,0,t.width,t.height)},initRadialGradient:function(){var t=this,e=t.$refs.c5,n=e.getContext("2d"),a=e.width,r=e.height,i=n.createRadialGradient(a/2,r,1,a/2,0,128);i.addColorStop(0,"blue"),i.addColorStop(.25,"white"),i.addColorStop(.5,"purple"),i.addColorStop(.75,"red"),i.addColorStop(1,"yellow"),n.fillStyle=i,n.fillRect(0,0,e.width,e.height)},drawTwoCircle:function(){var t=this,e=t.$refs.c6,n=e.getContext("2d"),a=e.width,r=e.height;n.fillStyle="rgba(0,0,0,0.5)",n.shadowColor="rgba(0,0,0,0.8)",n.shadowOffsetX=8,n.shadowOffsetY=8,n.shadowBlur=20,n.arc(a/2,r/2,100,0,2*Math.PI,!0),n.arc(a/2,r/2,70,0,2*Math.PI,!1),n.fill()},initGrid:function(){var t=this,e=t.$refs,n=e.c7,a=e.c8,r=e.c9,i=e.c10,o=e.grid,l=o.getBoundingClientRect(),s=.95*(l.right-l.left);n.setAttribute("width",s),a.setAttribute("width",s),r.setAttribute("width",s),i.setAttribute("width",s),t.drawGrid(n),t.drawGrid(a),t.drawGrid(r),t.drawGrid(i)},drawGrid:function(t){var e=t.getContext("2d"),n=t.width,a=t.height,r=10,i=10;e.clearRect(0,0,n,a),e.strokeStyle="#e0e0e0",e.lineWidth=.5;for(var o=r+.5;o<n;o+=r)e.beginPath(),e.moveTo(o,0),e.lineTo(o,a),e.stroke();for(var l=i+.5;l<a;l+=i)e.beginPath(),e.moveTo(0,l),e.lineTo(n,l),e.stroke()},drawDashedLine:function(){var t=this,e=t.$refs.c8,n=e.getContext("2d"),a=e.width,r=e.height,i={x:15,y:15},o={x:a-20,y:r-30},l=o.x-i.x,s=o.y-i.y,c=4,d=Math.floor(Math.sqrt(l*l+s*s)/c);n.beginPath(),n.strokeStyle="rgba(0,0,0,0.8)",n.lineWidth=1;for(var v=0;v<d;v++)n[v%2==0?"moveTo":"lineTo"](i.x+l/d*v,i.y+s/d*v);n.stroke()},drawRoundedRect:function(){var t=this,e=t.$refs.c9,n=e.getContext("2d"),a=Math.floor(.9*e.width),r=Math.floor(.9*e.height),i=(e.width-a)/2,o=(e.height-r)/2,l=20,s=i+a,c=o+r;n.strokeStyle="rgba(0,0,0,0.5)",n.fillStyle="rgba(0,0,0,0.3)",n.lineWidth=1,n.beginPath(),n.moveTo(i+l,o),n.arcTo(s,o,s,o+l,l),n.arcTo(s,c,s-l,c,l),n.arcTo(i,c,i,c-l,l),n.arcTo(i,o,i+l,o,l),n.stroke(),n.fill()},drawArrow:function(){var t=this,e=t.$refs.c10,n=e.getContext("2d"),a=30,r=e.width,i=e.height;n.strokeStyle="rgba(0,0,0,0.5)",n.fillStyle="rgba(0,0,0,0.3)",n.beginPath(),n.moveTo(r-a,2*a),n.lineTo(r-a,i-2*a),n.quadraticCurveTo(r-a,i-a,r-2*a,i-a),n.lineTo(r-250,i/2+a),n.quadraticCurveTo(r-300,i/2,r-250,i/2-a),n.lineTo(r-2*a,a),n.quadraticCurveTo(r-a,a,r-a,2*a),n.fill(),n.stroke()},drawClipAni:function(){var t=this,e=t.$refs.c11.getContext("2d"),n=e.canvas.width,a=e.canvas.height,r=n/2,i=-1;setInterval(function(){e.fillStyle="#999999",e.fillRect(0,0,n,a),i==-1?(r-=n/100,r>0?t.drawAni(r):i=1):(r+=n/100,r<n/2?t.drawAni(r):i=-1)},50)},drawClipText:function(){var t=this,e=t.$refs.c11.getContext("2d"),n=e.canvas.width,a=e.canvas.height;e.save(),e.font="normal 70px 微软雅黑",e.lineWidth=4,e.shadowColor="rgba(100,100,150,0.8)",e.shadowOffsetX=5,e.shadowOffsetY=5,e.shadowBlur=10,e.fillStyle="#ff6666",e.textAlign="center",e.textBaseline="middle",e.fillText("Canvas",n/2,a/2),e.restore()},drawAni:function(t){var e=this,n=e.$refs.c11.getContext("2d"),a=n.canvas.width,r=n.canvas.height;n.save(),n.beginPath(),n.arc(a/2,r/2,t,0,2*Math.PI,!0),n.clip(),n.fillStyle="#dddddd",n.fillRect(0,0,a,r),e.drawClipText(),n.restore()}}}},56:function(t,e,n){e=t.exports=n(5)(),e.push([t.id,".exp[data-v-023a6a3b]{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.gradient[data-v-023a6a3b]{-ms-flex-pack:distribute;justify-content:space-around;-ms-flex-wrap:wrap;flex-wrap:wrap;padding-bottom:5px!important}canvas[data-v-023a6a3b]{width:250px;height:250px!important;border:1px solid #e0e0e0;border-radius:4px}.gradient>canvas[data-v-023a6a3b]{margin-bottom:15px}.grid>canvas[data-v-023a6a3b]{width:95%}",""])},63:function(t,e,n){var a=n(56);"string"==typeof a&&(a=[[t.id,a,""]]);n(6)(a,{});a.locals&&(t.exports=a.locals)},83:function(t,e,n){var a,r;n(63),a=n(21);var i=n(119);r=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(r=a=a.default),"function"==typeof r&&(r=r.options),r.render=i.render,r.staticRenderFns=i.staticRenderFns,r._scopeId="data-v-023a6a3b",t.exports=a},119:function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"page article"},[n("h2",{staticClass:"title"},[t._v("Canvas学习笔记之二：绘制")]),t._v(" "),n("div",{staticClass:"content"},[n("h3",{staticClass:"title"},[t._v("Canvas的绘制模型")]),t._v(" "),n("p",[t._v("浏览器按照如下步骤来绘制图形：")]),t._v(" "),n("p",[t._v("(1)、将图形绘制到一个无限大的透明位图中，在绘制时遵循当前的填充模式、描边模式以及线条样式；")]),t._v(" "),n("p",[t._v("(2)、使用当前绘图环境的阴影设定将图形的阴影绘制到另外的一幅位图中；")]),t._v(" "),n("p",[t._v("(3)、将阴影中的每一个像素的alpha分量乘以绘图环境对象的globalAlpha属性值；")]),t._v(" "),n("p",[t._v("(4)、将绘有阴影的位图与经过剪辑区域剪切过的canvas进行图像合成，使用当前的合成模式参数；")]),t._v(" "),n("p",[t._v("(5)、将图形的每一个像素颜色分量，乘以绘图环境对象的globalAlpha属性值；")]),t._v(" "),n("p",[t._v("(6)、将绘有图形的位图，合成到当前经过剪辑区域剪切过的canvas位图之上，使用当前的合成操作符。")]),t._v(" "),n("p",[t._v("只有在启用阴影时才会执行第2~4步。")]),t._v(" "),n("h3",{staticClass:"title"},[t._v("矩形的绘制")]),t._v(" "),n("p",[t._v("Canvas提供如下3个api，分别用于矩形的清除、描边、填充：")]),t._v(" "),t._m(0),t._v(" "),n("h3",{staticClass:"title"},[t._v("渐变色")]),t._v(" "),n("p",[t._v("Canvas支持线性（linear）渐变与放射（radial）渐变。")]),t._v(" "),t._m(1),t._v(" "),n("div",{staticClass:"exp gradient"},[n("canvas",{ref:"c1",attrs:{width:"250",height:"250"}}),t._v(" "),n("canvas",{ref:"c2",attrs:{width:"250",height:"250"}}),t._v(" "),n("canvas",{ref:"c3",attrs:{width:"250",height:"250"}}),t._v(" "),n("canvas",{ref:"c4",attrs:{width:"250",height:"250"}})]),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),n("p",[t._v("创建线性渐变，需要使用两个圆，他们表示某个圆锥的起始位置。")]),t._v(" "),n("div",{staticClass:"exp gradient"},[n("canvas",{ref:"c5",attrs:{width:"290",height:"290"}})]),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),n("h3",{staticClass:"title"},[t._v("图案填充")]),t._v(" "),t._m(6),t._v(" "),n("p",[t._v('使用createPattern(patternObj, repeatTypeString)方法创建图案，patternObj指的是图案元素，repeatTypeString指的是图案的重复方式："repeat"、"repeat-x"、"repeat-y"以及"no-repeat"4种方式。')]),t._v(" "),n("h3",{staticClass:"title"},[t._v("阴影")]),t._v(" "),n("p",[t._v("阴影效果通过如下4个属性值设置：")]),t._v(" "),t._m(7),t._v(" "),n("h3",{staticClass:"title"},[t._v("路径、描边与填充")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),n("p",[t._v("绘制圆环：")]),t._v(" "),n("div",{staticClass:"exp circle"},[n("canvas",{ref:"c6",attrs:{width:"250",height:"250"}})]),t._v(" "),t._m(11),t._v(" "),n("h3",{staticClass:"title"},[t._v("线段")]),t._v(" "),t._m(12),t._v(" "),n("p",[t._v("网格的绘制：")]),t._v(" "),n("div",{ref:"grid",staticClass:"exp grid"},[n("canvas",{ref:"c7",attrs:{width:"250",height:"250"}})]),t._v(" "),t._m(13),t._v(" "),n("p",[t._v("虚线的绘制：")]),t._v(" "),n("div",{staticClass:"exp grid"},[n("canvas",{ref:"c8",attrs:{width:"250",height:"250"}})]),t._v(" "),t._m(14),t._v(" "),n("p",[t._v("lineCap的取值：butt、round、square，默认为butt，控制线段端点的绘制。")]),t._v(" "),n("p",[t._v("lineJoin的取值：round、bevel、miter，默认值为miter，控制线段的连接点的绘制。")]),t._v(" "),n("p",[t._v("miterLimit：斜接线长度与二分之一线宽的比值，如果斜接线的长度超过了此值，浏览器将以bevel的方式绘制线段的连接点。")]),t._v(" "),n("h3",{staticClass:"title"},[t._v("圆弧与圆形")]),t._v(" "),n("p",[t._v("arc()方法所绘制可能不仅仅是圆弧，如果当前路径有子路径的话，浏览器会将子路径的终点与圆弧的起点用线段连接起来。")]),t._v(" "),n("p",[t._v("另外一个用于创建圆弧路径的方法是arcTo(x1,y1,x2,y2,radius)，参数分别代表两个点及半径，此圆弧与当前点到第一个点(x1,y1)，的连线相切，并且与(x1,y1)到(x2,y2)的连线也相切。")]),t._v(" "),n("p",[t._v("圆角矩形的绘制：")]),t._v(" "),n("div",{ref:"grid",staticClass:"exp grid"},[n("canvas",{ref:"c9",attrs:{width:"250",height:"250"}})]),t._v(" "),t._m(15),t._v(" "),n("h3",{staticClass:"title"},[t._v("贝塞尔曲线")]),t._v(" "),t._m(16),t._v(" "),n("p",[t._v("平方贝塞尔曲线使用quadraticCurveTo方法绘制，接受四个参数，分别表示控制点和锚点的X、Y坐标。所绘制的曲线，会将锚点与当前路径中最后一个点连接起来。")]),t._v(" "),n("p",[t._v("使用贝赛尔曲线绘制圆角：")]),t._v(" "),n("div",{staticClass:"exp grid"},[n("canvas",{ref:"c10",attrs:{width:"250",height:"250"}})]),t._v(" "),t._m(17),t._v(" "),n("h3",{staticClass:"title"},[t._v("坐标系的变换")]),t._v(" "),n("p",[t._v("Canvas中平移、旋转、缩放坐标系的方法：")]),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),n("p",[t._v("坐标(x, y)绕原点旋转angle角度之后的坐标(x', y')计算如下：")]),t._v(" "),t._m(21),t._v(" "),n("p",[t._v("矩阵变换有下面的方程式：")]),t._v(" "),t._m(22),t._v(" "),n("h3",{staticClass:"title"},[t._v("剪辑区域")]),t._v(" "),n("p",[t._v("由路径定义的一块区域，浏览器会将所有的绘图操作都限制在本区域内。默认情况下剪辑区域就是整个Canvas，除非创建路径并调用clip()方法显式地设置剪辑区域。")]),t._v(" "),n("p",[t._v("利用剪辑区域实现的伸缩式动画：")]),t._v(" "),n("div",{staticClass:"exp clip"},[n("canvas",{ref:"c11",staticStyle:{width:"280px",height:"280px !important"},attrs:{width:"280",height:"280"}})]),t._v(" "),t._m(23)]),t._v(" "),n("footer",[t._v("2016年06月15日")]),t._v(" "),n("comments")],1)},staticRenderFns:[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("clearRect(double x, double y, double w, double h)\nstrokeRect(double x, double y, double w, double h)\nfillRect(double x, double y, double w, double h)")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[t._v("线性渐变通过调用"),n("strong",[t._v("createLinearGradient()")]),t._v("方法创建，需要向该方法传入两个点的坐标，两点之间的连线就是canvas建立线性渐变效果的依据，该方法会返回CanvasGradient实例。可以添加颜色停止点设置渐变色。")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("initLinearGradient () {\n    let that = this\n    let refs = that.$refs\n    let w = 250\n    let h = 250\n    that.drawLinearGradient(refs.c1, {x0: 0, y0: 0, x1: w, y1: 0})\n    that.drawLinearGradient(refs.c2, {x0: 0, y0: 0, x1: 0, y1: h})\n    that.drawLinearGradient(refs.c3, {x0: 0, y0: 0, x1: w, y1: h})\n    that.drawLinearGradient(refs.c4, {x0: 0, y0: 0, x1: 0, y1: h / 2})\n}\ndrawLinearGradient (el, pos) {\n    let context = el.getContext('2d')\n    let gradient = context.createLinearGradient(pos.x0, pos.y0, pos.x1, pos.y1)\n    gradient.addColorStop(0, 'blue')\n    gradient.addColorStop(0.25, 'white')\n    gradient.addColorStop(0.5, 'purple')\n    gradient.addColorStop(0.75, 'red')\n    gradient.addColorStop(1, 'yellow')\n    context.fillStyle = gradient\n    context.fillRect(0, 0, el.width, el.height)\n}")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[n("strong",[t._v("使用线性渐变填充时，Canvas会使用最后一种颜色来填充非渐变区域。")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("let context = el.getContext('2d')\nlet w = el.width\nlet h = el.height\nlet gradient = context.createRadialGradient(w / 2, h, 1, w / 2, 0, 128)\ngradient.addColorStop(0, '#333')\ngradient.addColorStop(1, '#fff')\ncontext.fillStyle = gradient\ncontext.fillRect(0, 0, el.width, el.height)")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[n("strong",[t._v("放射渐变的填充范围仅局限于两个圆形所定义的圆锥区域，不会使用最后一个渐变色填充剩余区域。")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[t._v("Canavs允许使用图案对图形和文本进行填充，图案元素可以是这3种："),n("strong",[t._v("Image元素、Video元素、canvas元素。")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ol",[n("li",[t._v("1、shadowColor：CSS3格式的颜色，默认值：rgba(0,0,0,0)；")]),t._v(" "),n("li",[t._v("2、shadowOffsetX：阴影的水平像素偏移；")]),t._v(" "),n("li",[t._v("3、shadowOffsetY：阴影的垂直像素偏移；")]),t._v(" "),n("li",[t._v("4、shadowBlur：一个与像素无关的值，该值被用于高斯模糊方程之中。")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[t._v("strokeRect()和fillRect()是Canavs中仅有的两个可以立即绘制图形的方法，其他方法都是基于路径的。"),n("strong",[t._v("不论一个路径是否开放或者封闭，都可以进行填充。")]),t._v("与路径有关的方法：")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ol",[n("li",[t._v("1、"),n("strong",[t._v("beginPath()")]),t._v("：将当前路径下的子路径都清除，以此重置当前路径；")]),t._v(" "),n("li",[t._v("2、"),n("strong",[t._v("closePath()")]),t._v("：显式地封闭某段开放路径；")]),t._v(" "),n("li",[t._v("3、"),n("strong",[t._v("fill()")]),t._v("：填充；")]),t._v(" "),n("li",[t._v("4、"),n("strong",[t._v("stroke()")]),t._v("：描边；")]),t._v(" "),n("li",[t._v("5、"),n("strong",[t._v("rect(x,y,w,h)")]),t._v("：添加矩形子路径，逆时针方向创建；")]),t._v(" "),n("li",[t._v("6、"),n("strong",[t._v("arc(centerX,centerY,radius,startAngle,endAngle,counterClockwise)")]),t._v("：添加圆弧子路径，counterClockwise默认为false(顺时针)，设置为true则逆时针。")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[t._v("填充路径是使用"),n("strong",[t._v("非零环绕原则")]),t._v("：从区域内部画一条足够长的线段，与路径的顺时针部分相交则加1，逆时针部分相交则-1，如果最终值为0则不填充该区域，否则填充。")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("drawTwoCircle () {\n    let that = this\n    let el = that.$refs.c6\n    let context = el.getContext('2d')\n    let w = el.width\n    let h = el.height\n    context.fillStyle = 'rgba(0,0,0,0.5)'\n    context.shadowColor = 'rgba(0,0,0,0.8)'\n    context.shadowOffsetX = 8\n    context.shadowOffsetY = 8\n    context.shadowBlur = 20\n    context.arc(w / 2, h / 2, 100, 0, 2 * Math.PI, true)\n    context.arc(w / 2, h / 2, 70, 0, 2 * Math.PI, false)\n    context.fill()\n}")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[t._v("主要有两个API："),n("strong",[t._v("moveTo(x,y)")]),t._v("和"),n("strong",[t._v("lineTo(x,y)")]),t._v("。"),n("strong",[t._v("如果要绘制一像素的线条，需要将其绘制在某两个像素之间的那个像素中。")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("drawGrid () {\n    let that = this\n    let el = that.$refs.c7\n    let context = el.getContext('2d')\n    let w = el.width\n    let h = el.height\n    let stepX = 10\n    let stepY = 10\n\n    context.clearRect(0, 0, w, h)\n    context.strokeStyle = '#e0e0e0'\n    context.lineWidth = 0.5\n    for (let i = stepX + 0.5; i < w; i += stepX) {\n        context.beginPath()\n        context.moveTo(i, 0)\n        context.lineTo(i, h)\n        context.stroke()\n    }\n\n    for (let j = stepY + 0.5; j < h; j += stepY) {\n        context.beginPath()\n        context.moveTo(0, j)\n        context.lineTo(w, j)\n        context.stroke()\n    }\n}")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("drawDashedLine () {\n    let that = this\n    let el = that.$refs.c8\n    let context = el.getContext('2d')\n    let w = el.width\n    let h = el.height\n    let startPoint = {x: 15, y: 15}\n    let endPoint = {x: w - 20, y: h - 30}\n    let deltX = endPoint.x - startPoint.x\n    let deltY = endPoint.y - startPoint.y\n    let dashLen = 4\n    let num = Math.floor(Math.sqrt(deltX * deltX + deltY * deltY) / dashLen)\n\n    context.beginPath()\n    context.strokeStyle = 'rgba(0,0,0,0.8)'\n    context.lineWidth = 1\n    for (let i = 0; i < num; i++) {\n        context[i % 2 == 0 ? 'moveTo' : 'lineTo'](startPoint.x + (deltX / num) * i, startPoint.y + (deltY / num) * i)\n    }\n    context.stroke()\n}")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("drawRoundedRect () {\n    let that = this\n    let el = that.$refs.c9\n    let context = el.getContext('2d')\n    let w = Math.floor(el.width * 0.9)\n    let h = Math.floor(el.height * 0.9)\n    let startX = (el.width - w) / 2\n    let startY = (el.height - h) / 2\n    let radius = 20\n    let endX = startX + w\n    let endY = startY + h\n    context.strokeStyle = 'rgba(0,0,0,0.5)'\n    context.fillStyle = 'rgba(0,0,0,0.3)'\n    context.lineWidth = 1\n    context.beginPath()\n    context.moveTo(startX + radius, startY)\n    context.arcTo(endX, startY, endX, startY + radius, radius)\n    context.arcTo(endX, endY, endX - radius, endY, radius)\n    context.arcTo(startX, endY, startX, endY - radius, radius)\n    context.arcTo(startX, startY, startX + radius, startY, radius)\n    context.stroke()\n    context.fill()\n}")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[t._v("分为"),n("strong",[t._v("平方贝塞尔曲线")]),t._v("（由两个锚点和一个控制点）和"),n("strong",[t._v("立方贝塞尔曲线")]),t._v("（两个锚点以及两个控制点）。")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("drawArrow () {\n    let that = this\n    let el = that.$refs.c10\n    let context = el.getContext('2d')\n    let margin = 30\n    let w = el.width\n    let h = el.height\n    context.strokeStyle = 'rgba(0,0,0,0.5)'\n    context.fillStyle = 'rgba(0,0,0,0.3)'\n    context.beginPath()\n    context.moveTo(w - margin, margin * 2)\n    context.lineTo(w - margin, h - margin * 2)\n    context.quadraticCurveTo(w - margin, h - margin, w - margin * 2, h - margin)\n    context.lineTo(w - 250, h / 2 + margin)\n    context.quadraticCurveTo(w - 300, h / 2, w - 250, h / 2 - margin)\n    context.lineTo(w - margin * 2, margin)\n    context.quadraticCurveTo(w - margin, margin, w - margin, margin * 2)\n    context.fill()\n    context.stroke()\n}")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ol",[n("li",[t._v("1、"),n("strong",[t._v("rotate(angle)")]),t._v("：按照给定的角度旋转坐标系；")]),t._v(" "),n("li",[t._v("2、"),n("strong",[t._v("scale(x, y)")]),t._v("：在X、Y方向上按照设定的数值来缩放坐标系；")]),t._v(" "),n("li",[t._v("3、"),n("strong",[t._v("translate(x, y)")]),t._v("：在X、Y方向上平移坐标系。")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[n("strong",[t._v("水平镜像变换：scale(-1, 1)；垂直镜像变换：scale(1, -1)。")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("p",[t._v("操作变换矩阵的方法："),n("strong",[t._v("transform(a,b,c,d,e,f)")]),t._v("（在当前的变换矩阵之上叠加运用变换效果）和"),n("strong",[t._v("setTransform(a,b,c,d,e,f)")]),t._v("（重置当前的变换矩阵）。两者可以实现上面三种变换方法无法实现的变换，比如错切。")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("x' = x * cos(angle) - y * sin(angle)\ny' = y * cos(angle) + y * sin(angle)")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("x' = a * x + c * y + e\ny' = b * x + d * y + f")])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("pre",[n("code",[t._v("drawClipAni () {\n    let that = this\n    let context = that.$refs.c11.getContext('2d')\n    let w = context.canvas.width\n    let h = context.canvas.height\n    let radius = w / 2\n    let direction = -1\n\n    setInterval(function () {\n        context.fillStyle = '#333333'\n        context.fillRect(0, 0, w, h)\n        if (direction == -1) {\n            radius -= w / 100\n            if (radius > 0) {\n                that.drawAni(radius)\n            } else {\n                direction = 1\n            }\n        } else {\n            radius += w / 100\n            if (radius < w / 2) {\n                that.drawAni(radius)\n            } else {\n                direction = -1\n            }\n        }\n    }, 50)\n},\ndrawClipText () {\n    let that = this\n    let context = that.$refs.c11.getContext('2d')\n    let w = context.canvas.width\n    let h = context.canvas.height\n    context.save()\n    context.font = 'normal 70px 微软雅黑'\n    context.lineWidth = 4\n    context.shadowColor = 'rgba(100,100,150,0.8)'\n    context.shadowOffsetX = 5\n    context.shadowOffsetY = 5\n    context.shadowBlur = 10\n\n    context.fillStyle = '#ff6666'\n    context.textAlign = 'center'\n    context.textBaseline = 'middle'\n    context.fillText('Canvas', w / 2, h / 2)\n    context.restore()\n},\ndrawAni (radius) {\n    let that = this\n    let context = that.$refs.c11.getContext('2d')\n    let w = context.canvas.width\n    let h = context.canvas.height\n\n    context.save()\n    context.beginPath()\n    context.arc(w / 2, h / 2, radius, 0, 2 * Math.PI, true)\n    context.clip()\n    context.fillStyle = '#dddddd'\n    context.fillRect(0, 0, w, h)\n    that.drawClipText()\n    context.restore()\n}")])])}]}}});