webpackJsonp([38],{VXWZ:function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var v={extends:e("3ErM").a},o={render:function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"page article"},[e("h2",{staticClass:"title"},[t._v("ES6标准入门笔记之一：let与const命令")]),t._v(" "),t._m(0),t._v(" "),e("footer",[t._v("2017年03月08日")]),t._v(" "),e("Comments"),t._v(" "),e("Catalog",{attrs:{catalog:t.catalog}})],1)},staticRenderFns:[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[e("p",[t._v("ECMAScript 6（ES6）是JavaScript语言的下一代标准，2015年6月正式发布。计划以后每年发布一次标准，ES6又称ECMAScript 2015.")]),t._v(" "),e("p",[e("strong",[t._v("ECMAScript和JavaScript的关系：一个是国际标准，一个是标准的实现。")])]),t._v(" "),e("p",[t._v("2013年3月，ES6草案封闭，不再接受新的功能。新功能将被加入ES7。")]),t._v(" "),e("p",[t._v("向TC39提交的提案，变成正式标准需要经历5个阶段："),e("strong",[t._v("Strawman（展示阶段）、Proposal（征求意见阶段）、Draft（草案阶段）、Candidate（候选阶段）、Finished（定案阶段）。")])]),t._v(" "),e("h3",{staticClass:"title"},[t._v("let命令")]),t._v(" "),e("p",[t._v("用于声明变量，作用类似var，但只在let变量的代码块内有效。")]),t._v(" "),e("p",[t._v("for循环的计数器，很适合使用let命令：for(let i = 0; i < len; i++) {}")]),t._v(" "),e("p",[e("strong",[t._v("不存在变量提升：")]),t._v("变量必须先声明后使用，否则报错。")]),t._v(" "),e("p",[e("strong",[t._v("暂时性死区：")]),t._v("只要块级作用域内存在let命令，它所声明的变量就“绑定”在这个区域，不受外部的影响。此时变量已存在，但不可获取。只有在声明之后才可使用。")]),t._v(" "),e("pre",[e("code",[t._v("var tmp = 123\nif (true) {\n    tmp = 234 // 报错 ReferenceError\n    let tmp\n}")])]),t._v(" "),e("p",[e("strong",[t._v("在代码块内，使用let、const声明变量之前，该变量都是不可用的，语法上称之为“暂时性死区”。")])]),t._v(" "),e("p",[t._v("let不允许在相同的作用域内重复声明同一个变量。")]),t._v(" "),e("h3",{staticClass:"title"},[t._v("块级作用域")]),t._v(" "),e("p",[t._v("let为JavaScript新增了块级作用域：")]),t._v(" "),e("pre",[e("code",[t._v("function f1() {\n    let n = 5\n    if (true) {\n        let n = 10 // 内层块，不影响外部\n    }\n    console.log(n) // 5\n}")])]),t._v(" "),e("p",[t._v("ES6允许块级作用域任意嵌套，外层作用域无法读取内层变量，内层作用域可以定义外层作用域同名的变量。")]),t._v(" "),e("p",[t._v("在ES5中，函数声明会提升到当前作用域的顶部得到执行。ES6支持块级作用域，内部声明的函数不会影响到外部。"),e("i",[t._v("（书中的例子好像有问题）")])]),t._v(" "),e("p",[t._v("在严格模式下，函数只能在顶层作用域内和函数内声明，其他情况下（if代码块、循环代码块）声明都会报错。")]),t._v(" "),e("h3",{staticClass:"title"},[t._v("const命令")]),t._v(" "),e("p",[t._v("const用来声明变量。"),e("strong",[t._v("一旦声明，其值就不能改变。")]),t._v("意味着必须立即初始化，不能在以后赋值。")]),t._v(" "),e("p",[t._v("const的作用域与let相同，只在声明所在的块级作用域内有效。")]),t._v(" "),e("p",[t._v("对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。"),e("strong",[t._v("const命令只是保证地址不变，数据是可变的。")])]),t._v(" "),e("p",[t._v("如果想将对象冻结，可以使用Object.freeze方法。除了将对象冻结，也可以将属性冻结。")]),t._v(" "),e("p",[t._v("利用递归彻底冻结一个对象：")]),t._v(" "),e("pre",[e("code",[t._v("var constantize = (obj) => {\n    Object.freeze(obj)\n    Object.keys(obj).forEach( (key, value) => {\n        if (typeof obj[key] === 'object') {\n            constantize(obj[key])\n        }\n    })\n}")])]),t._v(" "),e("p",[t._v("ES6一共有6种声明变量的方法：var、function、let、const、import、class")]),t._v(" "),e("h3",{staticClass:"title"},[t._v("跨模块常量")]),t._v(" "),e("p",[t._v("const声明的变量只在当前代码块有效，跨模块常量可以如下设置：")]),t._v(" "),e("pre",[e("code",[t._v("// constants.js\nexport const A = 1\nexport const B = 2\n\n// test1.js\nimport * as constants from './constants'\nconsole.log(constants.A)\nconsole.log(constants.A)\n\n// test2.js\nimport {A, B} from './constants'\nconsole.log(A)\nconsole.log(B)")])]),t._v(" "),e("p",[e("strong",[t._v("全局对象在浏览器环境中是window对象，在node.js中是global对象。")])])])}]},s=e("Z0/y")(v,o,!1,null,null,null);n.default=s.exports}});